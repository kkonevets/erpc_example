/*
 * Generated by erpcgen 1.13.0 on Tue Jul 23 19:34:30 2024.
 *
 * AUTOGENERATED - DO NOT EDIT
 */


#if ERPC_ALLOCATION_POLICY == ERPC_ALLOCATION_POLICY_DYNAMIC
#include "erpc_port.h"
#endif
#include "erpc_codec.hpp"
#include "example_client.hpp"
#include "erpc_manually_constructed.hpp"

#if 11300 != ERPC_VERSION_NUMBER
#error "The generated shim code version is different to the rest of eRPC code."
#endif

using namespace erpc;
using namespace std;
using namespace erpcShim;



IO_client::IO_client(ClientManager *manager)
:m_clientManager(manager)
{
}

IO_client::~IO_client()
{
}

// IO interface say_hi function client shim.
char * IO_client::say_hi(const char * name)
{
    erpc_status_t err = kErpcStatus_Success;

    char * result = NULL;

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = m_clientManager->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = m_clientManager->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(message_type_t::kInvocationMessage, m_serviceId, m_say_hiId, request.getSequence());

        {
            uint32_t name_len = strlen((const char*)name);

            codec->writeString(name_len, (const char*)name);
        }

        // Send message to server
        // Codec status is checked inside this function.
        m_clientManager->performRequest(request);

        {
            uint32_t return_len;
            char * return_local;
            codec->readString(return_len, &return_local);
            result = (char*) erpc_malloc((return_len + 1) * sizeof(char));
            if ((result == NULL) || (return_local == NULL))
            {
                codec->updateStatus(kErpcStatus_MemoryError);
            }
            else
            {
                memcpy(result, return_local, return_len);
                (result)[return_len] = 0;
            }
        }

        err = codec->getStatus();
    }

    // Dispose of the request.
    m_clientManager->releaseRequest(request);

    // Invoke error handler callback function
    m_clientManager->callErrorHandler(err, m_say_hiId);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = m_clientManager->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    return result;
}
